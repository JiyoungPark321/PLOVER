#### 버블링

- 한 요소에 이벤트가 발생하면 요소에 할당된 핸들러가 동작하고, 이어서 부모의 핸들러도 동작합니다.
- 가장 최상위 부모를 만날때까지 위 과정이 반복되며, 각각 할당된 핸들러가 동작합니다.

```html
<style>
    body * {
        margin: 10px;
        border: 1px solid blue;
    }
</style>

<form onclick="alert('form')">FORM
    <div onclick="alert('div')">DIV
        <p onclick="alert('p')">P</p>
    </div>
</form>
```

> p를 클릭하면 alert('p') => alert('div') => alert('form') 순으로 실행됩니다.
> div를 클릭하면 alert('div') => alert('form') 순으로 실행됩니다.
> form을 클릭하면 alert('form')만 실행됩니다.

#### event.target과 event.currentTarget의 차이

- event.target은 실제 이벤트가 발생한 가장안쪽 요소입니다.
- this(event.currentTarget)는 현재 실행중인 핸들러가 할당된 요소입니다. 

```html
<style>
    body * {
        margin: 10px;
        border: 1px solid blue;
    }
</style>

<form>FORM
    <div>DIV
        <p>P</p>
    </div>
</form>

<script>
    form.onclick = function(event){
        event.target.style.backgroundColor = "yellow";
        
        setTimeout(()=> {
            alert('target='+event.target.tagName+" ,this="+this.tagName); 
            event.target.style.backgroundColor = '';
        },0);
    }
</script>
```

> this.tagName은 항상 FORM이다.
> event.target.tagName은 클릭한 태그가 표시될 것이다.

### 버블링 중단하기
- 버블링은 이벤트가 발생한 요소부터 최상위 요소까지 핸들러가 동작하는 개념입니다.
- 핸들러에 이벤트 처리후 버블링을 중단하도록 명령 할 수도 있습니다.
- event.stopPropagation()을 사용하면 해당 요소에서 버블링이 멈추고 상위요소로 전파되지 않습니다.

```
<body onclick="alert('no reachable')">
    <button onclick="event.stopPropagation()">클릭해주세요.</button>
</body>
```

> alert('no reachable')은 실행되지 않습니다.

#### 캡처링

- 이벤트가 발생하면 버블링이외에도 캡처링이 라는 흐름이 존재합니다.
- 캡처링은 최상위 부모로부터 이벤트가 발생한 요소까지 내려오면서 핸들러가 실행되는 개념입니다.(버블링과반대)
- 이벤트 흐름은 캡처링 -> 해당요소 핸들러실행 -> 버블링 순으로 진행됩니다.
- on<event> 프로퍼티, HTML속성, addEventListener는 기본적으로 버블링단계에서만 핸들러가 동작합니다.
- 캡처링을 사용하고 싶다면 elem.addEventListener(..., true)와 같이 두번째 인자로 true를 입력하면됩니다.(false는 기본값-버블링)

```
<style>
    body * {
        margin: 10px;
        border: 1px solid blue;
    }
</style>

<form>FORM
    <div>DIV
        <p>P</p>
    </div>
</form>

<script>
    for(let elem of document.querySelectorAll('*')){ //모든 요소에 캡처링과 버블링 핸들러를 등록한다.
        elem.addEventListener('click',e => alert(`캡처링:${elem.tagName}`),true);
        elem.addEventListener('click',e => alert(`버블링:${elem.tagName}`));
    }
</script>
```

> HTML->BODY->FORM->DIV(여기까지가 캡처링)->P->P->DIV(여기서부터 버블링)->FORM->BODY->HTML 순으로 핸들러가 동작합니다.


#### 이벤트 위임

- 요소마다 핸들러를 할당하지 않고, 요소의 공통조상에 이벤트 핸들러를 하나만 할당하여 여러요소를 한번에 다루는 기법
- 캡처링과 버블링을 활용한 기법이다.

```javascript
<style>
    td {
        width: 50px;
        height: 50px;
        text-align: center;
    }
</style>
<table id="table">
    <tr>
        <td>1</td>
        <td>2</td>
    </tr>
    <tr>
        <td>3</td>
        <td>4</td>
    </tr>
</table>
<script>
    let selected;
    table.onclick = function (event) {
        if (selected) {
            selected.style.background = '';
        }
        event.target.style.background = 'yellow';
        selected = event.target;
    }
</script>
```

> td의 공통 조상인 table에 이벤트 핸들러를 설정하여 td를 클릭할때마다 해당 td의 배경을 yellow로
> 기존 선택되었던 엘리먼트의 배경을 없애는 형태로 모든 td를 컨트롤한다.

- elem.closest(selector) 메서드는 elem의 상위 요소 중 selector와 일치하는 가장가까운 조상요소를 반환한다.

```
...
<table id="table">
    <tr>
        <td><strong>1<strong></td>
        <td><strong>2<strong></td>
    </tr>
    <tr>
        <td><strong>3<strong></td>
        <td><strong>4<strong></td>
    </tr>
</table>
<script>
    let selected;
    table.onclick = function (event) {
        let td = event.target.closest('td');
        if(!td) return; //조상중 td가 없다면 return
        if (selected) {
            selected.style.background = '';
        }
        td.style.background = 'yellow';
        selected = td;
    }
</script>
```
> strong을 클릭할경우 event.target은 strong이 되기때문에 색상지정이 되지않는다.
> 그럴경우 event.target.closest('td')를 사용한다.

#### 이벤트 위임 활용하기

- 저장하기,불러오기,검색하기 등의 버튼메뉴를 구성할때 메뉴 전체에 핸들러하나를 추가한다.
- 각 버튼의 data-action 속성값을 이용해 호출할 메서드를 할당한다.

```javascript
<div id="menu">
    <button data-action="save">저장하기</button>
    <button data-action="load">불러오기</button>
    <button data-action="search">검색하기</button>
</div>

<script>
    class Menu{
        constructor(elem){
            this._elem = elem;
            elem.onclick = this.onClick.bind(this);
        }

        save(){
            alert('저장하기');
        }

        load(){
            alert('불러오기');
        }    
        search(){
            alert('검색하기');
        }

        onClick(event){
            let action = event.target.dataset.action;
            if(action){
                this[action]();
            }
        };
    }

    new Menu(menu);
</script> 
```

#### 행동패턴

- 이벤트 위임은 요소에 선언전 방식으로 `행동`을 추가할떄 사용할 수도 있다.
- 행동패턴의 두부분 : 요소행동을 설명하는 속성을 요소에 추가,문서전체를 감지하는 핸들러가 이벤트를 추적(1에서 추가한 속성이 있는 요소에서 이벤트 발생시 작업수행로직 작성)

```javascript
//카운터 구현
<input type="button" value="1" data-counter />
<input type="button" value="1" data-counter />

<script>
    document.addEventListener('click', function (event) {
        if (event.target.dataset.counter !== undefined) {
            event.target.value++;
        }
    });
</script>
```

```javascript
//토글러구현
<button data-toggle-id="send_email">이메일 폼 토글</button>
<form id="send_email" hidden>
    이메일 : <input type="email" />
</form>

<script>
    document.addEventListener('click', function (event) {
        if (event.target.dataset.toggleId !== undefined) {
            let form = document.getElementById(event.target.dataset.toggleId);
            form.hidden = !form.hidden;
        }
    });
</script>
```